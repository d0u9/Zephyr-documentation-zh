# 定时服务

## 概念

纳内核定时器使用内核的系统时钟来度量花费的时间，该方法的度量单位是滴答数。它主要被线使用。

纳内核的定时服务允许线或任务在忙于执行其他工作时能够判断一个预定的时间是否已经到达。当需要同时监控多个时间间隔时，线程能够使用多个定时器。

纳内核定时器指向一个用户数据结构，该数据结构由使用该定时器的线程提供。该数据结构的指针会在定时器超时时被返回。用户数据结构必须满足至少4字节的长度，并且按照4字节进行对齐，内核会保留该区域的前32bit空间为其自身使用。该区域的剩余部分能够用来保存任何线程认为有助于使用定时器的相关数据。

可以定义任意数量的纳内核定时器。每个定时器是一个类型结构为nano_timer的变量，并且通过一个指向该变量的指针被引用。

纳内核定时器启动时会指定一个持续时间，也就是在该定时器超时之前的时钟滴答数。

> Note: 在确定纳内核定时器超时时间时需要特别小心，在启动定时器后，定时器测量的第一个滴答会小于完整的一个滴答间隔。例如，当系统时钟周期是10毫秒时，启动一个定时器在一个滴答后超时会造成定时器实际的超时时间可能不到一毫秒，也可能接近10毫秒。为了保证定时器的超时时间至少有`N`个滴答，需要设定超时时间为`N+1`个滴答。

在定时器启动后，定时器能够以阻塞或非阻塞方式进行测试，从而允许线程确定定时器是否超时。当定时器超时时，内核会返回指向用户数据的指针，如果定时器没有超时，内核要么会返回`NULL`（对于非阻塞测试方法），或者等待定时器超时（对于阻塞测试方法）。

> Note：纳内核在任何时候都不允许多于一个的线程等待定时器。如果第二个线程开始等待，只有第一个等待定时器的线程会在超时时被唤醒，而第二个线程会保持等待。
>
> 当任务在等待纳内核定时器时会进行忙等待（busy wait）。对于纳内核的应用的后台任务来讲，这并不会造成什么问题，但是对于微内核应用来讲，一个等待纳内核定时器的任务会保持为当前任务（current task），同时它会阻止其他具有相同或较低优先级的任务运行。

纳内核定时器在被启动后可以被取消。取消一个仍然在运行的定时器会造成其立即超时，因此，也会唤醒等待该定时器的线程。取消一个已经超时的定时器并不会产生任何效果。

纳内核定时器能在其超时后被重新使用，但在其运行时不能重新启动。如果有需求，可以在定时器再次启动之前重新初始化该定时器，使其指向不同的用户数据结构。

## 目标


